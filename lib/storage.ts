import { createClient } from "@supabase/supabase-js"
import type {
  BusinessProfile,
  Document,
  ChatMessage,
  Conversation,
  ComplianceItem,
  Task,
  User,
  UpsertUser,
  ProgressTask,
  OperatingAgreement,
  AiUsage,
} from "./schema"
import { db } from "./database"
import { eq, desc } from "drizzle-orm"
import { users, businessProfiles, conversations, messages } from "./schema" // Importing the required tables

const supabase = createClient(process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE_KEY!)

// Interface for storage operations
export interface IStorage {
  // User operations
  getUser(id: string): Promise<User | undefined>
  upsertUser(user: UpsertUser): Promise<User>

  // Business profile operations
  getUserBusinessProfiles(userId: string): Promise<BusinessProfile[]>
  getUserBusinessProfile(userId: string): Promise<BusinessProfile | undefined>
  getBusinessProfile(id: string): Promise<BusinessProfile | undefined>
  createBusinessProfile(profile: Omit<BusinessProfile, "id" | "created_at" | "updated_at">): Promise<BusinessProfile>
  updateBusinessProfile(id: string, updates: Partial<BusinessProfile>): Promise<BusinessProfile>

  // Conversation operations
  getUserConversations(userId: string): Promise<Conversation[]>
  getConversation(id: string): Promise<Conversation | undefined>
  createConversation(conversation: Omit<Conversation, "id" | "created_at" | "updated_at">): Promise<Conversation>
  updateConversationTitle(id: string, title: string): Promise<void>

  // Message operations
  getConversationMessages(conversationId: string): Promise<ChatMessage[]>
  createMessage(message: Omit<ChatMessage, "id" | "created_at">): Promise<ChatMessage>

  // Progress tracking operations
  getUserProgressTasks(userId: string): Promise<ProgressTask[]>
  getProgressTask(id: string): Promise<ProgressTask | undefined>
  createProgressTask(task: Omit<ProgressTask, "id" | "created_at" | "updated_at">): Promise<ProgressTask>
  updateProgressTask(id: string, updates: Partial<ProgressTask>): Promise<ProgressTask>
  createDefaultProgressTasks(userId: string, businessId?: string): Promise<void>

  // Document operations
  getUserDocuments(userId: string): Promise<Document[]>
  createDocument(document: Omit<Document, "id" | "created_at" | "updated_at">): Promise<Document>
  updateDocument(id: string, updates: Partial<Document>): Promise<Document>

  // Compliance operations
  getUserBusinessCompliance(userId: string): Promise<ComplianceItem | undefined>
  createBusinessCompliance(
    compliance: Omit<ComplianceItem, "id" | "created_at" | "updated_at">,
  ): Promise<ComplianceItem>
  updateBusinessCompliance(id: string, updates: Partial<ComplianceItem>): Promise<ComplianceItem>

  // Compliance task operations
  getUserComplianceTasks(userId: string): Promise<Task[]>
  getComplianceTask(id: string): Promise<Task | undefined>
  createComplianceTask(task: Omit<Task, "id" | "created_at" | "updated_at">): Promise<Task>
  updateComplianceTask(id: string, updates: Partial<Task>): Promise<Task>
  deleteComplianceTask(id: string): Promise<void>
  createDefaultComplianceTasks(userId: string, complianceId: string): Promise<void>
  cleanupDuplicateTasks(userId: string): Promise<void>
  clearAutoGeneratedTasks(userId: string): Promise<void>

  // Operating Agreement operations
  getUserOperatingAgreements(userId: string): Promise<OperatingAgreement[]>
  getOperatingAgreement(id: string): Promise<OperatingAgreement | undefined>
  createOperatingAgreement(
    agreement: Omit<OperatingAgreement, "id" | "created_at" | "updated_at">,
  ): Promise<OperatingAgreement>

  // AI Usage tracking operations
  getUserUsage(userId: string, month: string): Promise<AiUsage | undefined>
  createOrUpdateUsage(
    userId: string,
    month: string,
    incrementMessages?: number,
    incrementTokens?: number,
  ): Promise<AiUsage>
  getUserCurrentUsage(userId: string): Promise<{ messageCount: number; tokenCount: number }>
  updateOperatingAgreement(id: string, updates: Partial<OperatingAgreement>): Promise<OperatingAgreement>
  deleteOperatingAgreement(id: string): Promise<void>
}

export class DatabaseStorage implements IStorage {
  // User operations
  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id))
    return user
  }

  async upsertUser(userData: UpsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(userData)
      .onConflictDoUpdate({
        target: users.id,
        set: {
          ...userData,
          updatedAt: new Date(),
        },
      })
      .returning()

    return user
  }

  // Business profile operations
  async getUserBusinessProfiles(userId: string): Promise<BusinessProfile[]> {
    return await db
      .select()
      .from(businessProfiles)
      .where(eq(businessProfiles.userId, userId))
      .orderBy(desc(businessProfiles.createdAt))
  }

  async getUserBusinessProfile(userId: string): Promise<BusinessProfile | undefined> {
    const [profile] = await db.select().from(businessProfiles).where(eq(businessProfiles.userId, userId))
    return profile
  }

  async getBusinessProfile(id: string): Promise<BusinessProfile | undefined> {
    const [profile] = await db.select().from(businessProfiles).where(eq(businessProfiles.id, id))
    return profile
  }

  async createBusinessProfile(
    profile: Omit<BusinessProfile, "id" | "created_at" | "updated_at">,
  ): Promise<BusinessProfile> {
    const { data, error } = await supabase.from("business_profiles").insert(profile).select().single()

    if (error) throw error
    return data
  }

  async updateBusinessProfile(id: string, updates: Partial<BusinessProfile>): Promise<BusinessProfile> {
    const { data, error } = await supabase
      .from("business_profiles")
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq("id", id)
      .select()
      .single()

    if (error) throw error
    return data
  }

  // Conversation operations
  async getUserConversations(userId: string): Promise<Conversation[]> {
    return await db
      .select()
      .from(conversations)
      .where(eq(conversations.userId, userId))
      .orderBy(desc(conversations.updatedAt))
  }

  async getConversation(id: string): Promise<Conversation | undefined> {
    const [conversation] = await db.select().from(conversations).where(eq(conversations.id, id))
    return conversation
  }

  async createConversation(
    conversation: Omit<Conversation, "id" | "created_at" | "updated_at">,
  ): Promise<Conversation> {
    const { data, error } = await supabase.from("conversations").insert(conversation).select().single()

    if (error) throw error
    return data
  }

  async updateConversationTitle(id: string, title: string): Promise<void> {
    await supabase.from("conversations").update({ title, updated_at: new Date().toISOString() }).eq("id", id)
  }

  // Message operations
  async getConversationMessages(conversationId: string): Promise<ChatMessage[]> {
    return await db
      .select()
      .from(messages)
      .where(eq(messages.conversationId, conversationId))
      .orderBy(messages.createdAt)
  }

  async createMessage(message: Omit<ChatMessage, "id" | "created_at">): Promise<ChatMessage> {
    const { data, error } = await supabase.from("chat_messages").insert(message).select().single()

    if (error) throw error
    return data
  }

  // Progress tracking operations
  async getUserProgressTasks(userId: string): Promise<ProgressTask[]> {
    const { data, error } = await supabase
      .from("progress_tasks")
      .select("*")
      .eq("user_id", userId)
      .order("order_index", { ascending: true })
      .order("created_at", { ascending: false })

    if (error) throw error
    return data
  }

  async getProgressTask(id: string): Promise<ProgressTask | undefined> {
    const { data, error } = await supabase.from("progress_tasks").select("*").eq("id", id).single()

    if (error) throw error
    return data
  }

  async createProgressTask(task: Omit<ProgressTask, "id" | "created_at" | "updated_at">): Promise<ProgressTask> {
    const { data, error } = await supabase.from("progress_tasks").insert(task).select().single()

    if (error) throw error
    return data
  }

  async updateProgressTask(id: string, updates: Partial<ProgressTask>): Promise<ProgressTask> {
    const { data, error } = await supabase
      .from("progress_tasks")
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq("id", id)
      .select()
      .single()

    if (error) throw error
    return data
  }

  async createDefaultProgressTasks(userId: string, businessId?: string): Promise<void> {
    const defaultTasks = [
      // Foundation Phase
      {
        userId,
        businessId,
        category: "foundation",
        taskName: "Business Idea Validation",
        description: "Research market demand and validate your business concept",
        orderIndex: 1,
      },
      {
        userId,
        businessId,
        category: "foundation",
        taskName: "Business Plan Creation",
        description: "Develop a comprehensive business plan with financial projections",
        orderIndex: 2,
      },
      // Legal Phase
      {
        userId,
        businessId,
        category: "legal",
        taskName: "Choose Business Entity Type",
        description: "Decide between LLC, Corporation, Partnership, or Sole Proprietorship",
        orderIndex: 3,
      },
      {
        userId,
        businessId,
        category: "legal",
        taskName: "Register Business Entity",
        description: "File Articles of Organization/Incorporation with your state",
        orderIndex: 4,
      },
      {
        userId,
        businessId,
        category: "legal",
        taskName: "Obtain EIN",
        description: "Apply for Federal Employer Identification Number (EIN) with IRS",
        orderIndex: 5,
      },
      // Financial Phase
      {
        userId,
        businessId,
        category: "financial",
        taskName: "Open Business Bank Account",
        description: "Separate personal and business finances with dedicated accounts",
        orderIndex: 6,
      },
      {
        userId,
        businessId,
        category: "financial",
        taskName: "Set Up Accounting System",
        description: "Choose and implement accounting software for bookkeeping",
        orderIndex: 7,
      },
      {
        userId,
        businessId,
        category: "financial",
        taskName: "Obtain Business Insurance",
        description: "Secure appropriate insurance coverage for your business type",
        orderIndex: 8,
      },
      // Compliance Phase
      {
        userId,
        businessId,
        category: "compliance",
        taskName: "Get Business Licenses",
        description: "Obtain required local and state business licenses",
        orderIndex: 9,
      },
      {
        userId,
        businessId,
        category: "compliance",
        taskName: "Register for State Taxes",
        description: "Register for state income tax, sales tax, and employment taxes",
        orderIndex: 10,
      },
    ]

    for (const task of defaultTasks) {
      await this.createProgressTask(task)
    }
  }

  // Document operations
  async getUserDocuments(userId: string): Promise<Document[]> {
    const { data, error } = await supabase
      .from("documents")
      .select("*")
      .eq("user_id", userId)
      .order("created_at", { ascending: false })

    if (error) throw error
    return data
  }

  async createDocument(document: Omit<Document, "id" | "created_at" | "updated_at">): Promise<Document> {
    const { data, error } = await supabase.from("documents").insert(document).select().single()

    if (error) throw error
    return data
  }

  async updateDocument(id: string, updates: Partial<Document>): Promise<Document> {
    const { data, error } = await supabase
      .from("documents")
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq("id", id)
      .select()
      .single()

    if (error) throw error
    return data
  }

  // Compliance operations
  async getUserBusinessCompliance(userId: string): Promise<ComplianceItem | undefined> {
    const { data, error } = await supabase.from("compliance_items").select("*").eq("user_id", userId).single()

    if (error) throw error
    return data
  }

  async createBusinessCompliance(
    compliance: Omit<ComplianceItem, "id" | "created_at" | "updated_at">,
  ): Promise<ComplianceItem> {
    const { data, error } = await supabase.from("compliance_items").insert(compliance).select().single()

    if (error) throw error
    return data
  }

  async updateBusinessCompliance(id: string, updates: Partial<ComplianceItem>): Promise<ComplianceItem> {
    const { data, error } = await supabase
      .from("compliance_items")
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq("id", id)
      .select()
      .single()

    if (error) throw error
    return data
  }

  // Compliance task operations
  async getUserComplianceTasks(userId: string): Promise<Task[]> {
    const { data, error } = await supabase
      .from("tasks")
      .select("*")
      .eq("user_id", userId)
      .order("due_date", { ascending: true })
      .order("created_at", { ascending: false })

    if (error) throw error
    return data
  }

  async getComplianceTask(id: string): Promise<Task | undefined> {
    const { data, error } = await supabase.from("tasks").select("*").eq("id", id).single()

    if (error) throw error
    return data
  }

  async createComplianceTask(task: Omit<Task, "id" | "created_at" | "updated_at">): Promise<Task> {
    const { data, error } = await supabase.from("tasks").insert(task).select().single()

    if (error) throw error
    return data
  }

  async updateComplianceTask(id: string, updates: Partial<Task>): Promise<Task> {
    const { data, error } = await supabase
      .from("tasks")
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq("id", id)
      .select()
      .single()

    if (error) throw error
    return data
  }

  async deleteComplianceTask(id: string): Promise<void> {
    const { error } = await supabase.from("tasks").delete().eq("id", id)

    if (error) throw error
  }

  async createDefaultComplianceTasks(userId: string, complianceId: string): Promise<void> {
    const compliance = await this.getUserBusinessCompliance(userId)
    if (!compliance) return

    const defaultTasks = [
      // Business Registration Tasks
      {
        userId,
        complianceId,
        category: "legal",
        taskName: "Articles of Organization Filed",
        description: "File Articles of Organization with state",
        status: "pending",
        priority: "high",
        autoGenerated: true,
        stateSpecific: true,
      },
      {
        userId,
        complianceId,
        category: "legal",
        taskName: "Registered Agent Appointed",
        description: "Appoint registered agent for business",
        status: "pending",
        priority: "high",
        autoGenerated: true,
        stateSpecific: true,
      },
      {
        userId,
        complianceId,
        category: "tax",
        taskName: "Federal EIN Obtained",
        description: "Obtain Federal Employer Identification Number",
        status: "pending",
        priority: "high",
        autoGenerated: true,
      },
      {
        userId,
        complianceId,
        category: "tax",
        taskName: "State Tax Registration",
        description: "Register for state income tax",
        status: "pending",
        priority: "high",
        autoGenerated: true,
        stateSpecific: true,
      },
    ]

    for (const task of defaultTasks) {
      await this.createComplianceTask(task as Omit<Task, "id" | "created_at" | "updated_at">)
    }
  }

  async cleanupDuplicateTasks(userId: string): Promise<void> {
    try {
      console.log("Starting cleanup for user:", userId)

      const { data, error } = await supabase.from("tasks").select("*").eq("user_id", userId)

      if (error) throw error

      console.log("Found", data.length, "total tasks")

      const taskGroups: { [key: string]: Task[] } = {}

      data.forEach((task) => {
        const key = task.taskName
        if (!taskGroups[key]) {
          taskGroups[key] = []
        }
        taskGroups[key].push(task)
      })

      let deletedCount = 0

      for (const taskName in taskGroups) {
        const tasks = taskGroups[taskName]
        if (tasks.length > 1) {
          console.log(`Found ${tasks.length} duplicates for task: ${taskName}`)

          tasks.sort((a: Task, b: Task) => {
            const aTime = a.created_at ? new Date(a.created_at).getTime() : 0
            const bTime = b.created_at ? new Date(b.created_at).getTime() : 0
            return bTime - aTime
          })

          const toDelete = tasks.slice(1)

          for (const task of toDelete) {
            await supabase.from("tasks").delete().eq("id", task.id)
            deletedCount++
          }
        }
      }

      console.log("Cleanup completed. Deleted", deletedCount, "duplicate tasks")
    } catch (error) {
      console.error("Error in cleanupDuplicateTasks:", error)
      throw error
    }
  }

  async clearAutoGeneratedTasks(userId: string): Promise<void> {
    try {
      console.log("Clearing auto-generated tasks for user:", userId)

      const { error } = await supabase.from("tasks").delete().eq("user_id", userId).eq("auto_generated", true)

      if (error) throw error

      console.log("Cleared auto-generated tasks")
    } catch (error) {
      console.error("Error clearing auto-generated tasks:", error)
      throw error
    }
  }

  // AI Usage tracking operations
  async getUserUsage(userId: string, month: string): Promise<AiUsage | undefined> {
    const { data, error } = await supabase
      .from("ai_usage")
      .select("*")
      .eq("user_id", userId)
      .eq("month", month)
      .single()

    if (error) throw error
    return data
  }

  async createOrUpdateUsage(
    userId: string,
    month: string,
    incrementMessages = 1,
    incrementTokens = 0,
  ): Promise<AiUsage> {
    const existing = await this.getUserUsage(userId, month)

    if (existing) {
      const { data, error } = await supabase
        .from("ai_usage")
        .update({
          message_count: (existing.message_count || 0) + incrementMessages,
          token_count: (existing.token_count || 0) + incrementTokens,
          updated_at: new Date().toISOString(),
        })
        .eq("id", existing.id)
        .select()
        .single()
      if (error) throw error
      return data
    } else {
      const { data, error } = await supabase
        .from("ai_usage")
        .insert({
          user_id: userId,
          month: month,
          message_count: incrementMessages,
          token_count: incrementTokens,
        })
        .select()
        .single()
      if (error) throw error
      return data
    }
  }

  async getUserCurrentUsage(userId: string): Promise<{ messageCount: number; tokenCount: number }> {
    const currentMonth = new Date().toISOString().slice(0, 7) // YYYY-MM format
    const usage = await this.getUserUsage(userId, currentMonth)
    return {
      messageCount: usage?.message_count || 0,
      tokenCount: usage?.token_count || 0,
    }
  }

  // Operating Agreement operations
  async getUserOperatingAgreements(userId: string): Promise<OperatingAgreement[]> {
    const { data, error } = await supabase
      .from("operating_agreements")
      .select("*")
      .eq("user_id", userId)
      .order("created_at", { ascending: false })

    if (error) throw error
    return data
  }

  async getOperatingAgreement(id: string): Promise<OperatingAgreement | undefined> {
    const { data, error } = await supabase.from("operating_agreements").select("*").eq("id", id).single()

    if (error) throw error
    return data
  }

  async createOperatingAgreement(
    agreement: Omit<OperatingAgreement, "id" | "created_at" | "updated_at">,
  ): Promise<OperatingAgreement> {
    const { data, error } = await supabase.from("operating_agreements").insert(agreement).select().single()

    if (error) throw error
    return data
  }

  async updateOperatingAgreement(id: string, updates: Partial<OperatingAgreement>): Promise<OperatingAgreement> {
    const { data, error } = await supabase
      .from("operating_agreements")
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq("id", id)
      .select()
      .single()

    if (error) throw error
    return data
  }

  async deleteOperatingAgreement(id: string): Promise<void> {
    const { error } = await supabase.from("operating_agreements").delete().eq("id", id)

    if (error) throw error
  }
}

export const storage = new DatabaseStorage()
