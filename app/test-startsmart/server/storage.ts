import {
  users,
  conversations,
  messages,
  businessProfiles,
  progressTasks,
  documents,
  businessCompliance,
  complianceTasks,
  documentVersions,
  legalReviews,
  reviewComments,
  operatingAgreements,
  aiUsage,
  type User,
  type UpsertUser,
  type Conversation,
  type Message,
  type BusinessProfile,
  type ProgressTask,
  type Document,
  type BusinessCompliance,
  type ComplianceTask,
  type InsertConversation,
  type InsertMessage,
  type InsertBusinessProfile,
  type InsertProgressTask,
  type InsertDocument,
  type InsertBusinessCompliance,
  type InsertComplianceTask,
  type DocumentVersion,
  type InsertDocumentVersion,
  type LegalReview,
  type InsertLegalReview,
  type ReviewComment,
  type InsertReviewComment,
  type OperatingAgreement,
  type InsertOperatingAgreement,
  type AiUsage,
  type InsertAiUsage,
} from "@shared/schema";
import { db } from "./db";
import { eq, desc, and, lt, ne } from "drizzle-orm";
import { nanoid } from "nanoid";
import { leadTracking, type LeadData } from "./leadTracking";

// Interface for storage operations
export interface IStorage {
  // User operations
  // (IMPORTANT) these user operations are mandatory for Replit Auth.
  getUser(id: string): Promise<User | undefined>;
  upsertUser(user: UpsertUser): Promise<User>;
  
  // Business profile operations
  getUserBusinessProfiles(userId: string): Promise<BusinessProfile[]>;
  getUserBusinessProfile(userId: string): Promise<BusinessProfile | undefined>;
  getBusinessProfile(id: string): Promise<BusinessProfile | undefined>;
  createBusinessProfile(profile: InsertBusinessProfile): Promise<BusinessProfile>;
  updateBusinessProfile(id: string, updates: Partial<InsertBusinessProfile>): Promise<BusinessProfile>;
  
  // Conversation operations
  getUserConversations(userId: string): Promise<Conversation[]>;
  getConversation(id: string): Promise<Conversation | undefined>;
  createConversation(conversation: InsertConversation): Promise<Conversation>;
  updateConversationTitle(id: string, title: string): Promise<void>;
  
  // Message operations
  getConversationMessages(conversationId: string): Promise<Message[]>;
  createMessage(message: InsertMessage): Promise<Message>;
  
  // Progress tracking operations
  getUserProgressTasks(userId: string): Promise<ProgressTask[]>;
  getProgressTask(id: string): Promise<ProgressTask | undefined>;
  createProgressTask(task: InsertProgressTask): Promise<ProgressTask>;
  updateProgressTask(id: string, updates: Partial<InsertProgressTask>): Promise<ProgressTask>;
  createDefaultProgressTasks(userId: string, businessId?: string): Promise<void>;
  
  // Document operations
  getUserDocuments(userId: string): Promise<Document[]>;
  createDocument(document: InsertDocument): Promise<Document>;
  updateDocument(id: string, updates: Partial<InsertDocument>): Promise<Document>;
  
  // Compliance operations
  getUserBusinessCompliance(userId: string): Promise<BusinessCompliance | undefined>;
  createBusinessCompliance(compliance: InsertBusinessCompliance): Promise<BusinessCompliance>;
  updateBusinessCompliance(id: string, updates: Partial<InsertBusinessCompliance>): Promise<BusinessCompliance>;
  
  // Compliance task operations
  getUserComplianceTasks(userId: string): Promise<ComplianceTask[]>;
  getComplianceTask(id: string): Promise<ComplianceTask | undefined>;
  createComplianceTask(task: InsertComplianceTask): Promise<ComplianceTask>;
  updateComplianceTask(id: string, updates: Partial<InsertComplianceTask>): Promise<ComplianceTask>;
  deleteComplianceTask(id: string): Promise<void>;
  createDefaultComplianceTasks(userId: string, complianceId: string): Promise<void>;
  cleanupDuplicateTasks(userId: string): Promise<void>;
  clearAutoGeneratedTasks(userId: string): Promise<void>;

  // Legal review operations
  getDocumentVersions(documentId: string): Promise<DocumentVersion[]>;
  getDocumentVersion(id: string): Promise<DocumentVersion | undefined>;
  createDocumentVersion(version: InsertDocumentVersion): Promise<DocumentVersion>;
  
  // Legal review operations
  getUserLegalReviews(userId: string): Promise<LegalReview[]>;
  getDocumentLegalReviews(documentId: string): Promise<LegalReview[]>;
  getLegalReview(id: string): Promise<LegalReview | undefined>;
  createLegalReview(review: InsertLegalReview): Promise<LegalReview>;
  updateLegalReview(id: string, updates: Partial<InsertLegalReview>): Promise<LegalReview>;
  deleteLegalReview(id: string): Promise<void>;
  
  // Review comment operations
  getReviewComments(reviewId: string): Promise<ReviewComment[]>;
  getReviewComment(id: string): Promise<ReviewComment | undefined>;
  createReviewComment(comment: InsertReviewComment): Promise<ReviewComment>;
  updateReviewComment(id: string, updates: Partial<InsertReviewComment>): Promise<ReviewComment>;
  deleteReviewComment(id: string): Promise<void>;
  
  // Operating Agreement operations
  getUserOperatingAgreements(userId: string): Promise<OperatingAgreement[]>;
  getOperatingAgreement(id: string): Promise<OperatingAgreement | undefined>;
  createOperatingAgreement(agreement: InsertOperatingAgreement): Promise<OperatingAgreement>;
  
  // AI Usage tracking operations
  getUserUsage(userId: string, month: string): Promise<AiUsage | undefined>;
  createOrUpdateUsage(userId: string, month: string, incrementMessages?: number, incrementTokens?: number): Promise<AiUsage>;
  getUserCurrentUsage(userId: string): Promise<{ messageCount: number; tokenCount: number }>;
  updateOperatingAgreement(id: string, updates: Partial<InsertOperatingAgreement>): Promise<OperatingAgreement>;
  deleteOperatingAgreement(id: string): Promise<void>;
}

export class DatabaseStorage implements IStorage {
  // User operations
  // (IMPORTANT) these user operations are mandatory for Replit Auth.

  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async upsertUser(userData: UpsertUser): Promise<User> {
    // Check if this is a new user
    const existingUser = await this.getUser(userData.id);
    const isNewUser = !existingUser;
    
    const [user] = await db
      .insert(users)
      .values(userData)
      .onConflictDoUpdate({
        target: users.id,
        set: {
          ...userData,
          updatedAt: new Date(),
        },
      })
      .returning();
    
    // If this is a new user, trigger lead tracking
    if (isNewUser) {
      const leadData: LeadData = {
        userId: user.id,
        email: user.email || '',
        firstName: user.firstName || undefined,
        lastName: user.lastName || undefined,
        profileImageUrl: user.profileImageUrl || undefined,
        createdAt: user.createdAt || new Date(),
        source: 'replit-auth'
      };
      
      // Fire and forget - don't wait for lead tracking to complete
      leadTracking.sendNewUserNotification(leadData).catch(error => {
        console.error('Lead tracking failed:', error);
      });
    }
    
    return user;
  }
  
  // Business profile operations
  async getUserBusinessProfiles(userId: string): Promise<BusinessProfile[]> {
    return await db
      .select()
      .from(businessProfiles)
      .where(eq(businessProfiles.userId, userId))
      .orderBy(desc(businessProfiles.createdAt));
  }
  
  async getUserBusinessProfile(userId: string): Promise<BusinessProfile | undefined> {
    const [profile] = await db
      .select()
      .from(businessProfiles)
      .where(eq(businessProfiles.userId, userId));
    return profile;
  }
  
  async getBusinessProfile(id: string): Promise<BusinessProfile | undefined> {
    const [profile] = await db
      .select()
      .from(businessProfiles)
      .where(eq(businessProfiles.id, id));
    return profile;
  }
  
  async createBusinessProfile(profile: InsertBusinessProfile): Promise<BusinessProfile> {
    const [newProfile] = await db
      .insert(businessProfiles)
      .values({ ...profile, id: nanoid() })
      .returning();
    return newProfile;
  }
  
  async updateBusinessProfile(id: string, updates: Partial<InsertBusinessProfile>): Promise<BusinessProfile> {
    const [updatedProfile] = await db
      .update(businessProfiles)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(businessProfiles.id, id))
      .returning();
    return updatedProfile;
  }
  
  // Conversation operations
  async getUserConversations(userId: string): Promise<Conversation[]> {
    return await db
      .select()
      .from(conversations)
      .where(eq(conversations.userId, userId))
      .orderBy(desc(conversations.updatedAt));
  }
  
  async getConversation(id: string): Promise<Conversation | undefined> {
    const [conversation] = await db
      .select()
      .from(conversations)
      .where(eq(conversations.id, id));
    return conversation;
  }
  
  async createConversation(conversation: InsertConversation): Promise<Conversation> {
    const [newConversation] = await db
      .insert(conversations)
      .values({ ...conversation, id: nanoid() })
      .returning();
    return newConversation;
  }
  
  async updateConversationTitle(id: string, title: string): Promise<void> {
    await db
      .update(conversations)
      .set({ title, updatedAt: new Date() })
      .where(eq(conversations.id, id));
  }
  
  // Message operations
  async getConversationMessages(conversationId: string): Promise<Message[]> {
    return await db
      .select()
      .from(messages)
      .where(eq(messages.conversationId, conversationId))
      .orderBy(messages.createdAt);
  }
  
  async createMessage(message: InsertMessage): Promise<Message> {
    const [newMessage] = await db
      .insert(messages)
      .values({ ...message, id: nanoid() })
      .returning();
    return newMessage;
  }
  
  // Progress tracking operations
  async getUserProgressTasks(userId: string): Promise<ProgressTask[]> {
    return await db
      .select()
      .from(progressTasks)
      .where(eq(progressTasks.userId, userId))
      .orderBy(progressTasks.orderIndex, progressTasks.createdAt);
  }
  
  async getProgressTask(id: string): Promise<ProgressTask | undefined> {
    const [task] = await db
      .select()
      .from(progressTasks)
      .where(eq(progressTasks.id, id));
    return task;
  }
  
  async createProgressTask(task: InsertProgressTask): Promise<ProgressTask> {
    const [newTask] = await db
      .insert(progressTasks)
      .values({ ...task, id: nanoid() })
      .returning();
    return newTask;
  }
  
  async updateProgressTask(id: string, updates: Partial<InsertProgressTask>): Promise<ProgressTask> {
    const [updatedTask] = await db
      .update(progressTasks)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(progressTasks.id, id))
      .returning();
    return updatedTask;
  }
  
  async createDefaultProgressTasks(userId: string, businessId?: string): Promise<void> {
    const defaultTasks = [
      // Foundation Phase
      {
        userId,
        businessId,
        category: "foundation",
        taskName: "Business Idea Validation",
        description: "Research market demand and validate your business concept",
        orderIndex: 1,
      },
      {
        userId,
        businessId,
        category: "foundation",
        taskName: "Business Plan Creation",
        description: "Develop a comprehensive business plan with financial projections",
        orderIndex: 2,
      },
      // Legal Phase
      {
        userId,
        businessId,
        category: "legal",
        taskName: "Choose Business Entity Type",
        description: "Decide between LLC, Corporation, Partnership, or Sole Proprietorship",
        orderIndex: 3,
      },
      {
        userId,
        businessId,
        category: "legal",
        taskName: "Register Business Entity",
        description: "File Articles of Organization/Incorporation with your state",
        orderIndex: 4,
      },
      {
        userId,
        businessId,
        category: "legal",
        taskName: "Obtain EIN",
        description: "Apply for Federal Employer Identification Number (EIN) with IRS",
        orderIndex: 5,
      },
      // Financial Phase
      {
        userId,
        businessId,
        category: "financial",
        taskName: "Open Business Bank Account",
        description: "Separate personal and business finances with dedicated accounts",
        orderIndex: 6,
      },
      {
        userId,
        businessId,
        category: "financial",
        taskName: "Set Up Accounting System",
        description: "Choose and implement accounting software for bookkeeping",
        orderIndex: 7,
      },
      {
        userId,
        businessId,
        category: "financial",
        taskName: "Obtain Business Insurance",
        description: "Secure appropriate insurance coverage for your business type",
        orderIndex: 8,
      },
      // Compliance Phase
      {
        userId,
        businessId,
        category: "compliance",
        taskName: "Get Business Licenses",
        description: "Obtain required local and state business licenses",
        orderIndex: 9,
      },
      {
        userId,
        businessId,
        category: "compliance",
        taskName: "Register for State Taxes",
        description: "Register for state income tax, sales tax, and employment taxes",
        orderIndex: 10,
      },
    ];

    for (const task of defaultTasks) {
      await this.createProgressTask(task);
    }
  }
  
  // Document operations
  async getUserDocuments(userId: string): Promise<Document[]> {
    return await db
      .select()
      .from(documents)
      .where(eq(documents.userId, userId))
      .orderBy(desc(documents.createdAt));
  }
  
  async createDocument(document: InsertDocument): Promise<Document> {
    const [newDocument] = await db
      .insert(documents)
      .values({ ...document, id: nanoid() })
      .returning();
    return newDocument;
  }
  
  async updateDocument(id: string, updates: Partial<InsertDocument>): Promise<Document> {
    const [updatedDocument] = await db
      .update(documents)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(documents.id, id))
      .returning();
    return updatedDocument;
  }

  // Compliance operations
  async getUserBusinessCompliance(userId: string): Promise<BusinessCompliance | undefined> {
    const [compliance] = await db
      .select()
      .from(businessCompliance)
      .where(eq(businessCompliance.userId, userId));
    return compliance;
  }

  async createBusinessCompliance(compliance: InsertBusinessCompliance): Promise<BusinessCompliance> {
    const id = nanoid();
    const [newCompliance] = await db
      .insert(businessCompliance)
      .values({ ...compliance, id })
      .returning();
    return newCompliance;
  }

  async updateBusinessCompliance(id: string, updates: Partial<InsertBusinessCompliance>): Promise<BusinessCompliance> {
    const [updated] = await db
      .update(businessCompliance)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(businessCompliance.id, id))
      .returning();
    return updated;
  }

  // Compliance task operations
  async getUserComplianceTasks(userId: string): Promise<ComplianceTask[]> {
    // First, check for and update any overdue tasks
    await this.updateOverdueTasks(userId);
    
    return await db
      .select()
      .from(complianceTasks)
      .where(eq(complianceTasks.userId, userId))
      .orderBy(complianceTasks.dueDate, complianceTasks.createdAt);
  }

  // Check for overdue tasks and update their status automatically
  async updateOverdueTasks(userId: string): Promise<void> {
    const today = new Date();
    today.setHours(0, 0, 0, 0); // Set to start of day for accurate comparison

    // Find tasks that are past due but not completed
    const overdueTasks = await db
      .select()
      .from(complianceTasks)
      .where(
        and(
          eq(complianceTasks.userId, userId),
          lt(complianceTasks.dueDate, today),
          and(
            ne(complianceTasks.status, "completed"),
            ne(complianceTasks.status, "overdue")
          )
        )
      );

    if (overdueTasks.length > 0) {
      console.log(`🚨 Found ${overdueTasks.length} overdue tasks for user ${userId}`);
      
      // Update all overdue tasks to "overdue" status
      for (const task of overdueTasks) {
        await db
          .update(complianceTasks)
          .set({ 
            status: "overdue",
            updatedAt: new Date()
          })
          .where(eq(complianceTasks.id, task.id));
        
        console.log(`⚠️ Task "${task.taskName}" marked as overdue (due: ${task.dueDate?.toISOString().split('T')[0]})`);
      }
    }
  }

  async getComplianceTask(id: string): Promise<ComplianceTask | undefined> {
    const [task] = await db
      .select()
      .from(complianceTasks)
      .where(eq(complianceTasks.id, id));
    return task;
  }

  async createComplianceTask(task: InsertComplianceTask): Promise<ComplianceTask> {
    const id = nanoid();
    const [newTask] = await db
      .insert(complianceTasks)
      .values({ ...task, id })
      .returning();
    return newTask;
  }

  async updateComplianceTask(id: string, updates: Partial<InsertComplianceTask>): Promise<ComplianceTask> {
    const [updated] = await db
      .update(complianceTasks)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(complianceTasks.id, id))
      .returning();
    return updated;
  }

  async deleteComplianceTask(id: string): Promise<void> {
    await db
      .delete(complianceTasks)
      .where(eq(complianceTasks.id, id));
  }

  async createDefaultComplianceTasks(userId: string, complianceId: string): Promise<void> {
    const compliance = await this.getUserBusinessCompliance(userId);
    if (!compliance) return;

    // Check if auto-generated tasks already exist for this compliance profile to prevent duplicates
    const existingAutoTasks = await db
      .select()
      .from(complianceTasks)
      .where(
        and(
          eq(complianceTasks.userId, userId),
          eq(complianceTasks.complianceId, complianceId),
          eq(complianceTasks.autoGenerated, true)
        )
      );
    
    if (existingAutoTasks.length > 0) return;

    const currentDate = new Date();
    
    // Base compliance tasks for all businesses
    const defaultTasks = [
      // Business Registration Tasks
      {
        userId,
        complianceId,
        category: "legal",
        taskName: "Articles of Organization Filed",
        description: "File Articles of Organization with state",
        status: "pending",
        priority: "high",
        autoGenerated: true,
        stateSpecific: true,
      },
      {
        userId,
        complianceId,
        category: "legal",
        taskName: "Registered Agent Appointed",
        description: "Appoint registered agent for business",
        status: "pending",
        priority: "high",
        autoGenerated: true,
        stateSpecific: true,
      },
      {
        userId,
        complianceId,
        category: "tax",
        taskName: "Federal EIN Obtained",
        description: "Obtain Federal Employer Identification Number",
        status: "pending",
        priority: "high",
        autoGenerated: true,
      },
      {
        userId,
        complianceId,
        category: "tax",
        taskName: "State Tax Registration",
        description: "Register for state income tax",
        status: "pending",
        priority: "high",
        autoGenerated: true,
        stateSpecific: true,
      },
    ];

    // Add state-specific annual tax filing tasks using compliance profile data
    if (compliance.stateOfFormation && compliance.entityType) {
      const { getStateTaxRequirements, stateTaxRequirements } = await import('./data/stateTaxRequirements');
      const entityType = this.mapBusinessStructureToEntityType(compliance.entityType);
      const taxReq = getStateTaxRequirements(compliance.stateOfFormation, entityType);
      
      console.log("State tax lookup:", {
        state: compliance.stateOfFormation,
        entityType,
        taxReq: taxReq ? "found" : "not found"
      });
      
      if (!taxReq) {
        // Try to convert state abbreviation to full name
        const fullStateName = this.getFullStateName(compliance.stateOfFormation);
        if (fullStateName) {
          const retryTaxReq = getStateTaxRequirements(fullStateName, entityType);
          if (retryTaxReq) {
            console.log("Found state using full name mapping:", fullStateName);
            // Use the retry result instead
            const [month, day] = retryTaxReq.dueDate.split(' ');
            const monthNumber = this.getMonthNumber(month);
            const dueDate = new Date(currentDate.getFullYear(), monthNumber - 1, parseInt(day) || 15);
            
            if (dueDate < currentDate) {
              dueDate.setFullYear(currentDate.getFullYear() + 1);
            }

            defaultTasks.push({
              userId,
              complianceId,
              category: "tax",
              taskName: `${fullStateName} State Tax Return`,
              description: `File ${retryTaxReq.form} by ${retryTaxReq.dueDate}${retryTaxReq.extension ? ` (extension available until ${retryTaxReq.extension})` : ''}${retryTaxReq.notes ? `. Note: ${retryTaxReq.notes}` : ''}`,
              status: "pending",
              priority: "high",
              dueDate,
              isRecurring: true,
              recurringPattern: "annually",
              autoGenerated: true,
              stateSpecific: true,
            });
          }
        }
      }
      
      if (taxReq) {
        // Calculate due date for current year
        const [month, day] = taxReq.dueDate.split(' ');
        const monthNumber = this.getMonthNumber(month);
        const dueDate = new Date(currentDate.getFullYear(), monthNumber - 1, parseInt(day) || 15);
        
        // If due date has passed, set for next year
        if (dueDate < currentDate) {
          dueDate.setFullYear(currentDate.getFullYear() + 1);
        }

        defaultTasks.push({
          userId,
          complianceId,
          category: "tax",
          taskName: `${compliance.stateOfFormation} State Tax Return`,
          description: `File ${taxReq.form} by ${taxReq.dueDate}${taxReq.extension ? ` (extension available until ${taxReq.extension})` : ''}${taxReq.notes ? `. Note: ${taxReq.notes}` : ''}`,
          status: "pending",
          priority: "high",
          dueDate,
          isRecurring: true,
          recurringPattern: "annually",
          autoGenerated: true,
          stateSpecific: true,
        });
      }
      
      // Add federal tax filing task using compliance profile entity type
      const federalForm = this.getFederalTaxForm(compliance.entityType);
      const [federalMonth, federalDay] = federalForm.dueDate.split(' ');
      const federalMonthNumber = this.getMonthNumber(federalMonth);
      const federalDueDate = new Date(currentDate.getFullYear(), federalMonthNumber - 1, parseInt(federalDay) || 15);
      
      if (federalDueDate < currentDate) {
        federalDueDate.setFullYear(currentDate.getFullYear() + 1);
      }

      defaultTasks.push({
        userId,
        complianceId,
        category: "tax",
        taskName: "Federal Tax Return",
        description: `File ${federalForm.form} by ${federalForm.dueDate}${federalForm.extension ? ` (extension available until ${federalForm.extension})` : ''}`,
        status: "pending",
        priority: "high",
        dueDate: federalDueDate,
        isRecurring: true,
        recurringPattern: "annually",
        autoGenerated: true,
      });
    }

    // Add quarterly estimated tax tasks
    const quarterlyMonths = [3, 5, 8, 0]; // April, June, Sept, Jan
    quarterlyMonths.forEach((month, index) => {
      const dueDate = new Date(currentDate.getFullYear(), month, 15);
      if (dueDate < currentDate) {
        dueDate.setFullYear(currentDate.getFullYear() + 1);
      }
      
      defaultTasks.push({
        userId,
        complianceId,
        category: "tax",
        taskName: `Federal Estimated Tax Payment - Q${index + 1}`,
        description: `Submit quarterly estimated tax payment`,
        status: "pending",
        priority: "medium",
        dueDate,
        isRecurring: true,
        recurringPattern: "quarterly",
        autoGenerated: true,
      });
    });

    // Add employment tasks if has employees
    if (compliance.hasEmployees) {
      defaultTasks.push({
        userId,
        complianceId,
        category: "employment",
        taskName: "Workers' Compensation Insurance",
        description: "Obtain workers' compensation insurance",
        status: "pending",
        priority: "medium",
        autoGenerated: true,
        stateSpecific: true,
      });
    }

    // Insert all default tasks
    for (const task of defaultTasks) {
      await this.createComplianceTask(task as InsertComplianceTask);
    }
  }

  private mapBusinessStructureToEntityType(structure: string): 'llc' | 'sCorp' | 'corporation' | 'soleProprietor' {
    switch (structure.toLowerCase()) {
      case 'llc':
      case 'limited liability company':
      case 'partnership':
        return 'llc';
      case 's-corp':
      case 's corp':
      case 's-corporation':
      case 's corporation':
        return 'sCorp';
      case 'c-corp':
      case 'c corp':
      case 'corporation':
      case 'c corporation':
      case 'c-corporation':
        return 'corporation';
      case 'sole proprietorship':
      case 'sole proprietor':
      case 'single member llc':
        return 'soleProprietor';
      default:
        return 'llc'; // Default fallback
    }
  }

  private getFederalTaxForm(structure: string): { form: string; dueDate: string; extension?: string } {
    switch (structure.toLowerCase()) {
      case 'llc':
      case 'limited liability company':
      case 'partnership':
        return { form: 'Form 1065', dueDate: 'March 15', extension: 'September 15 with Form 7004' };
      case 's-corp':
      case 's corp':
      case 's-corporation':
      case 's corporation':
        return { form: 'Form 1120-S', dueDate: 'March 15', extension: 'September 15 with Form 7004' };
      case 'c-corp':
      case 'c corp':
      case 'corporation':
      case 'c corporation':
      case 'c-corporation':
        return { form: 'Form 1120', dueDate: 'April 15', extension: 'October 15 with Form 7004' };
      case 'sole proprietorship':
      case 'sole proprietor':
      case 'single member llc':
        return { form: 'Form 1040, Schedule C', dueDate: 'April 15', extension: 'October 15 with Form 4868' };
      default:
        return { form: 'Form 1065', dueDate: 'March 15', extension: 'September 15 with Form 7004' };
    }
  }

  private getMonthNumber(monthName: string): number {
    const months: { [key: string]: number } = {
      'january': 1, 'february': 2, 'march': 3, 'april': 4, 'may': 5, 'june': 6,
      'july': 7, 'august': 8, 'september': 9, 'october': 10, 'november': 11, 'december': 12
    };
    return months[monthName.toLowerCase()] || 4; // Default to April
  }

  private getFullStateName(stateCode: string): string | null {
    const stateMapping: { [key: string]: string } = {
      'AL': 'Alabama', 'AK': 'Alaska', 'AZ': 'Arizona', 'AR': 'Arkansas', 'CA': 'California',
      'CO': 'Colorado', 'CT': 'Connecticut', 'DE': 'Delaware', 'FL': 'Florida', 'GA': 'Georgia',
      'HI': 'Hawaii', 'ID': 'Idaho', 'IL': 'Illinois', 'IN': 'Indiana', 'IA': 'Iowa',
      'KS': 'Kansas', 'KY': 'Kentucky', 'LA': 'Louisiana', 'ME': 'Maine', 'MD': 'Maryland',
      'MA': 'Massachusetts', 'MI': 'Michigan', 'MN': 'Minnesota', 'MS': 'Mississippi', 'MO': 'Missouri',
      'MT': 'Montana', 'NE': 'Nebraska', 'NV': 'Nevada', 'NH': 'New Hampshire', 'NJ': 'New Jersey',
      'NM': 'New Mexico', 'NY': 'New York', 'NC': 'North Carolina', 'ND': 'North Dakota', 'OH': 'Ohio',
      'OK': 'Oklahoma', 'OR': 'Oregon', 'PA': 'Pennsylvania', 'RI': 'Rhode Island', 'SC': 'South Carolina',
      'SD': 'South Dakota', 'TN': 'Tennessee', 'TX': 'Texas', 'UT': 'Utah', 'VT': 'Vermont',
      'VA': 'Virginia', 'WA': 'Washington', 'WV': 'West Virginia', 'WI': 'Wisconsin', 'WY': 'Wyoming',
      'DC': 'District of Columbia'
    };
    return stateMapping[stateCode.toUpperCase()] || null;
  }

  async cleanupDuplicateTasks(userId: string): Promise<void> {
    try {
      console.log("Starting cleanup for user:", userId);
      
      // Get all tasks for user
      const allTasks = await db
        .select()
        .from(complianceTasks)
        .where(eq(complianceTasks.userId, userId));

      console.log("Found", allTasks.length, "total tasks");

      // Group tasks by name to find duplicates (simple grouping by task name)
      const taskGroups: { [key: string]: ComplianceTask[] } = {};
      
      allTasks.forEach(task => {
        const key = task.taskName;
        if (!taskGroups[key]) {
          taskGroups[key] = [];
        }
        taskGroups[key].push(task);
      });

      let deletedCount = 0;

      // Delete duplicates (keep the most recent one)
      for (const taskName in taskGroups) {
        const tasks = taskGroups[taskName];
        if (tasks.length > 1) {
          console.log(`Found ${tasks.length} duplicates for task: ${taskName}`);
          
          // Sort by creation date and keep the most recent
          tasks.sort((a: ComplianceTask, b: ComplianceTask) => {
            const aTime = a.createdAt ? new Date(a.createdAt).getTime() : 0;
            const bTime = b.createdAt ? new Date(b.createdAt).getTime() : 0;
            return bTime - aTime;
          });
          
          const toDelete = tasks.slice(1); // Remove all but the first (most recent)
          
          for (const task of toDelete) {
            await db
              .delete(complianceTasks)
              .where(eq(complianceTasks.id, task.id));
            deletedCount++;
          }
        }
      }

      console.log("Cleanup completed. Deleted", deletedCount, "duplicate tasks");
    } catch (error) {
      console.error("Error in cleanupDuplicateTasks:", error);
      throw error;
    }
  }

  async clearAutoGeneratedTasks(userId: string): Promise<void> {
    try {
      console.log("Clearing auto-generated tasks for user:", userId);
      
      // Delete all auto-generated tasks for the user
      const result = await db
        .delete(complianceTasks)
        .where(
          and(
            eq(complianceTasks.userId, userId),
            eq(complianceTasks.autoGenerated, true)
          )
        );
      
      console.log("Cleared auto-generated tasks");
    } catch (error) {
      console.error("Error clearing auto-generated tasks:", error);
      throw error;
    }
  }

  // AI Usage tracking operations
  async getUserUsage(userId: string, month: string): Promise<AiUsage | undefined> {
    const [usage] = await db
      .select()
      .from(aiUsage)
      .where(and(eq(aiUsage.userId, userId), eq(aiUsage.month, month)));
    return usage;
  }

  async createOrUpdateUsage(userId: string, month: string, incrementMessages: number = 1, incrementTokens: number = 0): Promise<AiUsage> {
    const existing = await this.getUserUsage(userId, month);
    
    if (existing) {
      const [updated] = await db
        .update(aiUsage)
        .set({
          messageCount: (existing.messageCount || 0) + incrementMessages,
          tokenCount: (existing.tokenCount || 0) + incrementTokens,
          updatedAt: new Date(),
        })
        .where(eq(aiUsage.id, existing.id))
        .returning();
      return updated;
    } else {
      const [created] = await db
        .insert(aiUsage)
        .values({
          userId,
          month,
          messageCount: incrementMessages,
          tokenCount: incrementTokens,
        })
        .returning();
      return created;
    }
  }

  async getUserCurrentUsage(userId: string): Promise<{ messageCount: number; tokenCount: number }> {
    const currentMonth = new Date().toISOString().slice(0, 7); // YYYY-MM format
    const usage = await this.getUserUsage(userId, currentMonth);
    return {
      messageCount: usage?.messageCount || 0,
      tokenCount: usage?.tokenCount || 0,
    };
  }

  // Email reminder settings for Pro/Premium users
  async updateEmailReminderSettings(userId: string, enabled: boolean, daysBefore: number = 30): Promise<BusinessCompliance | null> {
    const [updated] = await db
      .update(businessCompliance)
      .set({
        emailRemindersEnabled: enabled,
        reminderDaysBefore: daysBefore,
        updatedAt: new Date()
      })
      .where(eq(businessCompliance.userId, userId))
      .returning();
    
    return updated || null;
  }

  async getEmailReminderSettings(userId: string): Promise<{ enabled: boolean; daysBefore: number } | null> {
    const [profile] = await db
      .select({
        emailRemindersEnabled: businessCompliance.emailRemindersEnabled,
        reminderDaysBefore: businessCompliance.reminderDaysBefore
      })
      .from(businessCompliance)
      .where(eq(businessCompliance.userId, userId));
    
    if (!profile) return null;
    
    return {
      enabled: profile.emailRemindersEnabled || false,
      daysBefore: profile.reminderDaysBefore || 30
    };
  }

  // Mark recurring tasks with proper rollover data
  async markTaskAsRecurring(taskId: string, frequency: string): Promise<void> {
    const task = await db
      .select()
      .from(complianceTasks)
      .where(eq(complianceTasks.id, taskId))
      .limit(1);

    if (task.length === 0) return;

    const originalTask = task[0];
    let nextDueDate = null;

    if (originalTask.dueDate) {
      const current = new Date(originalTask.dueDate);
      const next = new Date(current);
      
      switch (frequency.toLowerCase()) {
        case 'annual':
        case 'annually':
          next.setFullYear(next.getFullYear() + 1);
          break;
        case 'quarterly':
          next.setMonth(next.getMonth() + 3);
          break;
        case 'monthly':
          next.setMonth(next.getMonth() + 1);
          break;
      }
      nextDueDate = next;
    }

    await db
      .update(complianceTasks)
      .set({
        isRecurring: true,
        recurringFrequency: frequency,
        recurringPattern: frequency,
        originalDueDate: originalTask.dueDate,
        nextDueDate: nextDueDate,
        updatedAt: new Date()
      })
      .where(eq(complianceTasks.id, taskId));
  }

  // Get user email for reminder system
  async getUserEmail(userId: string): Promise<string | null> {
    const [user] = await db
      .select({ email: users.email })
      .from(users)
      .where(eq(users.id, userId));
    
    return user?.email || null;
  }
}

export const storage = new DatabaseStorage();
